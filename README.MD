## **Payments System**

- [Key Features](#key-features)
- [Getting Started](#getting-started)
- [Services](#services)
    - [Card Service](#card-service)
    - [Transaction Service](#transaction-service)
    - [User Service](#user-service)
- [Models](#models)
    -[Card Model](#card-model)
    -[Deposit Model](#deposit-model)
    -[Transaction Model](#transaction-model)
    -[User Model](#user-model)
- [Helper Functions](#helper-functions)
- [Unit Tests](#unit-tests)

# **Key Features**

1. GuestN.bs do not have access to services.
2. Registered users have their own unique customerId generated with which they can transact with other users.
3. Registered users can add cards (it is a mocking service, not a real credit card) - they are being automatically generated.
4. Assuming the cards are real and always with positive balances - users can deposit funds to their user/customer accounts.
5. If user has enough balance on the account, they could transfer funds to another user/customer accounts.
6. User view all related transactions separated in two tables:
    - received transactions;
    - sent transactions;
7. Users can not transfer zero or negative amounts - both for deposits and transactions.
8. User authentication through json web token (jwt) which is being signed and sent after user login;

# Getting Started
To get started with this project, follow these steps:

1. Clone the repository.
2. Install dependencies with npm install.
3. Open the terminal in src/server directory.
4. Type npm run start in the terminal and hit enter.
5. Visit `http://localhost:3000/`.


# Services

**N.B! Most services must be implemented as a DB transactions in order to achieve atomicity , but I failed to configure the mongoDB to work with transactions! If working with an actual DB this would have been solved with couple of lines of code.**


There are 3 main services with their own functionalities:

## Card Service 

`cardService.js` responsible for:
- card creation; - [Create Card](#create-card);
- card deletion - [Delete Card](#delete-card);
- getting all cards related to certain user - [Get User Cards](#get-user-cards);

cardService utilizes 2 private functions:

`generateCardNumber` - creating a random card number for the currently created card;
`createExpirationDate` - creating an expiration date for the currently created card;

### Create Card

It is an async function which accepts 3 parameters:

```javascript
    createCard(userId, schemaProvider, cardholder);
```

They are being supplied by the front-end's form.

The function creates a DB document and returns it: 
    
```javascript

    return await Card.create({

        owner_id: userId,
        cardholder: cardholder,
        card_number: cardNumber,
        expiration: expDate
    });
```
`card_number` and `expiration` properties are being generated by `generateCardNumber` and `createExpirationDate`;

### Delete Card

It is an async function which accepts 2 parameters:

```javascript
 deleteCard(userId, cardId)
```

If database fails to find card which is matching both filters it throws an error:

```javascript

const result = await Card.deleteOne({ _id: cardId, owner_id: userId });

    if (result.deletedCount == 0) {

        throw new MongooseError('You are not allowed to delete this card!');
    }
```
Therefore this is a database guard ensuring that only cards belonging to their users will be deleted.

After deleting the card from the Cards database, we have to delete it from User.cards[] array:

```javascript

await User.findByIdAndUpdate({ _id: userId }, { $pull: { cards: { _id: cardId } } });

```


### Get User Cards

It is a function which returns an array of card documents:

```javascript

exports.getUserCards = (userId) => {

    return Card.find({ owner_id: userId }).lean();
}
```

## Transaction Service 

 `transactionService.js` responsible for:
- Depositing funds- [Deposit Funds](#deposit-funds);
- Getting all deposits by userId - [Get Deposits](#get-deposits);
- Transfering funds between customer accounts - [Funds Transfer](#funds-transfer);
- Getting user transactions - [Get Transactions](#get-transactions);
    
`transactionService` utilizes 1 private function:

`formatDate` - formating card's expiration date for the frontend.


### Deposit Funds

This fnction accepts 4 parameters:

```javascript

  depositFunds (userId, amount, card_number, card_id);

```
 
 It throws an error if the deposited amount is less or equal to zero.


### Get Deposits

Getting all deposits related to cerain userId:

```javascript
    
    exports.getDeposits = async (userId) => {

    return await Deposit.find({ userId: userId });
    }

```

### Funds Transfer

Responsible for transfering the funds between user's accounts:

```javascript
exports.transferFunds = async (sender, receiver, amount) => {

    //...
}
```
- It throws an error if amount is zero or negative;
- It throws an error if the receiver customerId is not found;
- It throws an error if the user is sending funds to themselves, thus sender == receiver;
- It throws an error if the transfer amount is larger than user's available account balance;

After all conditional checks have been passed, we get get both documents - sender and receiver from the database and update their account balances respectively.
Then a transaction document is being created/saved to the database:

```javascript

     return await Transaction.create({ tid, sender, receiver, amount, transaction_date });

```

### Get Transactions

It is a function that returns an object with two arrays: One for the `sent` transactions and one for the `received` transactions:

```javascript

exports.getUserTransactions = async (customerId) => {

    return {
        sent: (await Transaction.find({ sender: customerId }).lean()).map(formatDate),
        received: (await Transaction.find({ receiver: customerId }).lean()).map(formatDate)
    };
}
```

## User Service
**`userService.js` responsible for:**
- Creating new user- [Create User](#create-user);
- Getting user data/details - [Get User Data](#get-user-data);
- Login - [Login](#login);
- Adding cards to User's array - [Add Card](#add-card);
    
### Create User 

It is a function that accepts one parameter - it is a formData object generated by the user registration form on the frontend:

```javascript

    exports.createUser = async (data) => {

    const email = await User.findOne({email: data.email})

    if (email) {

        throw new MongooseError('User with this email already exists!');
    }

    return await User.create(data);
    
    }

```
 
 If the email is taken, a new mongoose error is being thrown.

### Get User Data

This service accepts a userId and returns an object with User's detail as a js object:

```javascript

    exports.getUserData = async (userId) => {

    return await User.findOne({_id: userId}).lean();

    }
```

### Login

This service is responsible for logging in - it accepts an email and password:

```javascript

    exports.login = async (email, password) => {

        //...
    }
```
- It validates if user exists;
- It validates if user has provided a valid password;
- If all conditional checks are passed the function signs a json web token and returns it:

```javascript

    const token = await jwt.sign({ userId: user._id, first_name: user.first_name, last_name: user.last_name, customerId: user.customerId }, jwtSecret, { expiresIn: '1h' });

    return token;

```

### Add Card

This service validates if user has less than 5 cards and if they don't - a `createCard` service is being called, which creates a new card.
Then this card is being pushed to User's cards array:

```javascript

exports.addCard = async (userId, schemaProvider, cardholder) => {
    
    const user = await User.findOne({ _id: userId });

    if (user.cards.length >= 5) {
        throw new MongooseError('The card limit of 5 has been reached!');
    }

    const card = await createCard(userId, schemaProvider, cardholder);
    user.cards.push(card);
    await user.save();
    return card._id;
}

```

### Models

## Card Model

```javascript

const CardSchema = new mongoose.Schema({

    owner_id: String,
    cardholder: String,
    card_number: String,
    expiration: String,
})

```

Prior to saving the db record of the card, there is a pre middleware function called:


```javascript

//this function is used to mask the card number:

CardSchema.pre("save", maskCard);

function maskCard() {

    const masked = this.card_number.slice(0, 6)
        .concat('******')
        .concat(this.card_number
            .slice(-4));

    this.card_number = masked;
}

```

## Deposit Model

```javascript

const DepositSchema = new mongoose.Schema({

    userId: String,
    amount: Number,
    card_number: String,
    card_id: String,
    deposit_date: Date,

})

```


## Transaction Model

```javascript

const TransactionSchema = new mongoose.Schema({

    tid: String,
    sender: String,
    receiver: String,
    amount: Number,
    transaction_date: Date,

})

```


## User Model

User Model Schema:

```javascript

const UserSchema = new mongoose.Schema({

    first_name: {
        type: String,
        required: true
    },
    last_name: {
        type: String,
        required: true
    },
    email: {
        type: String,
        unique: true,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    
    address: String,
    phone: String,
    DOB: Date,

    cards: {
        type: [CardSchema],
        validate: [cardArrayLimit, '{PATH} exceeds the limit of 5']
    },    
    balance: Number,
    customerId: String
})

```

Before creating and modifying the user there is a virtual function which checks whether user's password and rePassword match:

```javascript

UserSchema.virtual("rePassword").set(function (value) {

    if (value != this.password) {
        throw new mongoose.MongooseError("Password missmatch!");
    }
});

```

Also there is a pre save middleware which encrypts the password and generates user's customerId by using util function `generateId` , then sets the user's account balance to 0:


```javascript


UserSchema.pre("save", async function () {

    if (this.__v !==  undefined) return;  //only generate customerId, password hash and set balance to 0 if document does not exist; 

    this.customerId = generateId('C0');
    this.password = await bcrypt.hash(this.password, 10);
    this.balance = 0;
});

```

### Helper Functions

1. `generateId` - it is used to generate random ID's. It accepts id_type (string) as an argument, which is the substring the ID starts with:

- 'C0' - for customerId's;
- 'T' - for transaction ID's (tid);

```javascript

function generateId(id_type) {

    let id = id_type;
    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

    for (let i = 1; i <= 10; i++) {

        let character = '';

        if (i % 2 == 0) {

            character = Math.floor(Math.random() * 10);
            id = id.concat(character);
            continue;
        }

        character = letters[Math.floor(Math.random() * letters.length)];
        id = id.concat(character);
    }
    return id;
}


```
2. `promisifiedJwt` dictionary:

This has been created in order to ease the work with jwt token.

```javascript

const jsonwebtoken = require('jsonwebtoken');
const { promisify } = require('util');

const jwt = {

    sign: promisify(jsonwebtoken.sign),
    verify: promisify(jsonwebtoken.verify)
}

module.exports = jwt;


```

### Unit Tests

In order to test services, open the /services/tests dir with your terminal.

Here are the commands for testing each service:

1. `userService` 

```bash 
mocha userService-test.js
``` 

2. `cardService` 

```bash 
mocha cardService-test.js
``` 

3. `transactionService` 

```bash 
mocha transactionService-test.js
``` 